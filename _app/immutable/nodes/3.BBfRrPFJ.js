import{s as h,a as p,e as m,n as v}from"../chunks/scheduler.FGUOCI5T.js";import{S as x,i as w,k as y,l as P,m as C,n as $,o as k,p as L,e as u,s as b,c as d,q as _,f as R,g as l,d as c}from"../chunks/index.D8TrmQgK.js";import{P as S,g as q,a as f}from"../chunks/post_layout.CevBiKrK.js";function G(i){let e,s="Let’s say we have a simple neural network. How do we know what input neurons were most important for the final prediction? Discuss perturbation, etc, etc. Generally speaking a neural network consists of non-linear functions. So what can we do, approximate all the nonlinear functions as first-order Taylor expansions! (make a diagram) We also have some nice properties like conservation and positivity but they are not strictly required (and more recent papers ignore these constraints!). go into the derivation. Go into AttnLRP. Go into Chefer.",o,n,t="^ Actually it might be a good idea to have a review paper…?";return{c(){e=u("p"),e.textContent=s,o=b(),n=u("p"),n.textContent=t},l(a){e=d(a,"P",{"data-svelte-h":!0}),_(e)!=="svelte-avnihn"&&(e.textContent=s),o=R(a),n=d(a,"P",{"data-svelte-h":!0}),_(n)!=="svelte-dx87xm"&&(n.textContent=t)},m(a,r){l(a,e,r),l(a,o,r),l(a,n,r)},p:v,d(a){a&&(c(e),c(o),c(n))}}}function T(i){let e,s;const o=[i[0],g];let n={$$slots:{default:[G]},$$scope:{ctx:i}};for(let t=0;t<o.length;t+=1)n=p(n,o[t]);return e=new S({props:n}),{c(){y(e.$$.fragment)},l(t){P(e.$$.fragment,t)},m(t,a){C(e,t,a),s=!0},p(t,[a]){const r=a&1?q(o,[a&1&&f(t[0]),a&0&&f(g)]):{};a&2&&(r.$$scope={dirty:a,ctx:t}),e.$set(r)},i(t){s||($(e.$$.fragment,t),s=!0)},o(t){k(e.$$.fragment,t),s=!1},d(t){L(e,t)}}}const g={title:"So what is Layerwise Relevance Propagation (LRP)?",image:"",alt:"",created:"2025-07-07T00:00:00.000Z",tags:["Machine Learning","Interpretability","Computer Science"],updated:"2025-07-08T04:51:13.406Z",images:[],slug:"/LRP1/+page.md",path:"/LRP1",toc:!1};function A(i,e,s){return i.$$set=o=>{s(0,e=p(p({},e),m(o)))},e=m(e),[e]}class H extends x{constructor(e){super(),w(this,e,A,T,h,{})}}export{H as component};
